cd
getwd()
cd ..
setwd("~/Documents/GitHub/MAUI")
getwd()
setwd("~/Documents/GitHub/MAUI")
<<<<<<< HEAD
## set working directory from which data files are imported and exported
setwd("~/Documents/GitHub/MAUI") # Mac filepath
getwd()
=======
getwd()
library(tidyverse)
library(readxl)
library(openxlsx)
set.seed(1729)
#' Everything relative to project folder '#
source('Code/bootstrapping subsample functions.R')
all_responses <- read_csv('Data/Garrett Dissertation Data Answers Only.csv')
#' part_items is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- read_csv('Data/participant table.csv') %>%
select(one_of(c('item', 'partID', 'flexibility'))) %>%
spread(item, flexibility)
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>%
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
N <- 100
focal_item <- 'U1'
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
smpl <- sample_ids(remains_flexbyitem, focal_item, N) #outputs bootstrap partIDs
boot_list <- bind_rows(holdout_nums, smpl) #participant IDs of holdout sample & resamples
boot_items <- sample_responses(all_responses, boot_list$partID, focal_item) #outputs all responses in entire bootstrap sample
boot_itemcount <- sort_count(boot_items) #outputs counts of bootstrap sample responses
boot_ranks <- ranks(boot_itemcount, N) #outputs MAUI rank table of bootstrap sample responses
boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_itemscores <- boot_itemcount %>%
left_join(select(boot_ranks, -cumsum, -mass))
boot_scores <- boot_items %>%
left_join(boot_itemscores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
#' SAVE SMPL_RANKS HERE FOR GRAPHING
#' ggplot(data = smpl_ranks, aes(x = MAUI, y = mass)) + geom_col() + xlim(0,1)
#' ggplot(data = smpl_ranks, aes(x = 1-pct_giving, y = mass)) + geom_col() + geom_vline(aes(xintercept = .95)) + xlim(0,1)
#'
#FIT GAMMA AND DELTA HERE
fit <- nls(curve_formula, smpl_calcs, start = list(d = .5, g = .6))
s <- filter(all_responses, partID == holdout_nums$partID[1] & TypeItem == 'U1')
new <- smpl_itemcount
install.packages('xlsx')
library(tidyverse)
library(readxl)
library(openxlsx)
set.seed(1729)
#' Everything relative to project folder '#
source('Code/bootstrapping subsample functions.R')
all_responses <- read_csv('Data/Garrett Dissertation Data Answers Only.csv')
#' part_items is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- read_csv('Data/participant table.csv') %>%
select(one_of(c('item', 'partID', 'flexibility'))) %>%
spread(item, flexibility)
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>%
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
N <- 100
focal_item <- 'U1'
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
smpl <- sample_ids(remains_flexbyitem, focal_item, N) #outputs bootstrap partIDs
boot_list <- bind_rows(holdout_nums, smpl) #participant IDs of holdout sample & resamples
boot_items <- sample_responses(all_responses, boot_list$partID, focal_item) #outputs all responses in entire bootstrap sample
boot_itemcount <- sort_count(boot_items) #outputs counts of bootstrap sample responses
boot_ranks <- ranks(boot_itemcount, N) #outputs MAUI rank table of bootstrap sample responses
boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_itemscores <- boot_itemcount %>%
left_join(select(boot_ranks, -cumsum, -mass))
boot_scores <- boot_items %>%
left_join(boot_itemscores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
#' SAVE SMPL_RANKS HERE FOR GRAPHING
#' ggplot(data = smpl_ranks, aes(x = MAUI, y = mass)) + geom_col() + xlim(0,1)
#' ggplot(data = smpl_ranks, aes(x = 1-pct_giving, y = mass)) + geom_col() + geom_vline(aes(xintercept = .95)) + xlim(0,1)
#'
#FIT GAMMA AND DELTA HERE
fit <- nls(curve_formula, smpl_calcs, start = list(d = .5, g = .6))
s <- filter(all_responses, partID == holdout_nums$partID[1] & TypeItem == 'U1')
new <- smpl_itemcount
install.packages('openxlsx')
library(tidyverse)
library(readxl)
library(openxlsx)
set.seed(1729)
#' Everything relative to project folder '#
source('Code/bootstrapping subsample functions.R')
all_responses <- read_csv('Data/Garrett Dissertation Data Answers Only.csv')
#' part_items is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- read_csv('Data/participant table.csv') %>%
select(one_of(c('item', 'partID', 'flexibility'))) %>%
spread(item, flexibility)
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>%
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
N <- 100
focal_item <- 'U1'
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
smpl <- sample_ids(remains_flexbyitem, focal_item, N) #outputs bootstrap partIDs
boot_list <- bind_rows(holdout_nums, smpl) #participant IDs of holdout sample & resamples
boot_items <- sample_responses(all_responses, boot_list$partID, focal_item) #outputs all responses in entire bootstrap sample
boot_itemcount <- sort_count(boot_items) #outputs counts of bootstrap sample responses
boot_ranks <- ranks(boot_itemcount, N) #outputs MAUI rank table of bootstrap sample responses
boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_itemscores <- boot_itemcount %>%
left_join(select(boot_ranks, -cumsum, -mass))
boot_scores <- boot_items %>%
left_join(boot_itemscores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
#' SAVE SMPL_RANKS HERE FOR GRAPHING
#' ggplot(data = smpl_ranks, aes(x = MAUI, y = mass)) + geom_col() + xlim(0,1)
#' ggplot(data = smpl_ranks, aes(x = 1-pct_giving, y = mass)) + geom_col() + geom_vline(aes(xintercept = .95)) + xlim(0,1)
#'
#FIT GAMMA AND DELTA HERE
fit <- nls(curve_formula, smpl_calcs, start = list(d = .5, g = .6))
s <- filter(all_responses, partID == holdout_nums$partID[1] & TypeItem == 'U1')
new <- smpl_itemcount
library(tidyverse)
library(readxl)
library(openxlsx)
set.seed(1729)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
#' part_items is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- read_csv('data/participant table.csv') %>%
select(one_of(c('item', 'partID', 'flexibility'))) %>%
spread(item, flexibility)
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>%
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
N <- 100
focal_item <- 'U1'
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
smpl <- sample_ids(remains_flexbyitem, focal_item, N) #outputs bootstrap partIDs
boot_list <- bind_rows(holdout_nums, smpl) #participant IDs of holdout sample & resamples
boot_items <- sample_responses(all_responses, boot_list$partID, focal_item) #outputs all responses in entire bootstrap sample
boot_itemcount <- sort_count(boot_items) #outputs counts of bootstrap sample responses
boot_ranks <- ranks(boot_itemcount, N) #outputs MAUI rank table of bootstrap sample responses
boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_itemscores <- boot_itemcount %>%
left_join(select(boot_ranks, -cumsum, -mass))
boot_scores <- boot_items %>%
left_join(boot_itemscores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
#' SAVE SMPL_RANKS HERE FOR GRAPHING
#' ggplot(data = smpl_ranks, aes(x = MAUI, y = mass)) + geom_col() + xlim(0,1)
#' ggplot(data = smpl_ranks, aes(x = 1-pct_giving, y = mass)) + geom_col() + geom_vline(aes(xintercept = .95)) + xlim(0,1)
#'
#FIT GAMMA AND DELTA HERE
fit <- nls(curve_formula, smpl_calcs, start = list(d = .5, g = .6))
s <- filter(all_responses, partID == holdout_nums$partID[1] & TypeItem == 'U1')
new <- smpl_itemcount
library(tidyverse)
library(readxl)
library(openxlsx)
set.seed(1729)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
#' part_items is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- read_csv('data/participant table.csv') %>% #'participant table is placeholder for all_responses, I think?
select(one_of(c('item', 'partID', 'flexibility'))) %>%
spread(item, flexibility)
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>%
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
N <- 100
focal_item <- 'U1'
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
smpl <- sample_ids(remains_flexbyitem, focal_item, N) #outputs bootstrap partIDs
boot_list <- bind_rows(holdout_nums, smpl) #participant IDs of holdout sample & resamples
boot_items <- sample_responses(all_responses, boot_list$partID, focal_item) #outputs all responses in entire bootstrap sample
boot_itemcount <- sort_count(boot_items) #outputs counts of bootstrap sample responses
boot_ranks <- ranks(boot_itemcount, N) #outputs MAUI rank table of bootstrap sample responses
boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_itemscores <- boot_itemcount %>%
left_join(select(boot_ranks, -cumsum, -mass))
boot_scores <- boot_items %>%
left_join(boot_itemscores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
#' SAVE SMPL_RANKS HERE FOR GRAPHING
#' ggplot(data = smpl_ranks, aes(x = MAUI, y = mass)) + geom_col() + xlim(0,1)
#' ggplot(data = smpl_ranks, aes(x = 1-pct_giving, y = mass)) + geom_col() + geom_vline(aes(xintercept = .95)) + xlim(0,1)
#'
#FIT GAMMA AND DELTA HERE
fit <- nls(curve_formula, smpl_calcs, start = list(d = .5, g = .6))
s <- filter(all_responses, partID == holdout_nums$partID[1] & TypeItem == 'U1')
new <- smpl_itemcount
install.packages('textclean')
library(openxlsx)
library(foreach)
library(textclean)
library(tidyverse)
library(readxl)
set.seed(1729)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
install.packages('foreach')
check_text(all_responses$Std)
df <- replace_non_ascii(all_responses$Std)
df <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ")
check_text(df)
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ")
all_responses <- sapply(all_responses$Std, tolower)
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ")
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ") %>%
tolower()
#' part_flexbyitem is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- std_to_flextable(all_responses, 'TypeItem', 'partID', 'FlexCat')
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>% #' ensures target sample did all 9 items
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
items <- names(part_flexbyitem)[-1] #item names from frame
N <- 100
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
library(foreach)
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
boot_list <- bind_rows(holdout_nums, filter(boot_parts, n==0)) #participant IDs of holdout sample & resamples
boot_items <- all_responses %>%
filter(partID %in% boot_list$partID) #'outputs all responses for all items on boot_list
boot_itemcount <- boot_items %>%
split(.$TypeItem) %>%
map(~sort_count(.)) #'outputs response count for standardized responses in a list of each item
View(boot_items)
View(boot_itemcount)
boot_itemcount[[F1]]
boot_itemcount[[1]]
boot_itemcount <- boot_items %>%
group_by(TypeItem) %>%
sort_count()
View(boot_itemcount)
library(openxlsx)
library(foreach)
library(tidyverse)
library(readxl)
set.seed(1729)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
tolower() #' turns everything to lowercase
#' part_flexbyitem is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- std_to_flextable(all_responses, 'TypeItem', 'partID', 'FlexCat')
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>% #' ensures target sample did all 9 items
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
items <- names(part_flexbyitem)[-1] #item names from frame
N <- 100
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
boot_list <- bind_rows(holdout_nums, filter(boot_parts, n==0)) #participant IDs of holdout sample & resamples
boot_items <- all_responses %>%
filter(partID %in% boot_list$partID) #'outputs all responses for all items on boot_list
boot_response_count <- foreach(i = items, .combine='rbind') %do% sort_count(boot_items, i)
boot_response_count <- foreach(i = items, .combine='rbind') %do% sort_count(boot_items)
View(boot_response_count)
View(boot_items)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
boot_response_count <- foreach(i = items, .combine='rbind') %do% sort_count(boot_items)
boot_response_count <- foreach(i = items, .combine='rbind') %do% sort_count(boot_items, i)
View(boot_response_count)
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
tolower() #' turns everything to lowercase
#' part_flexbyitem is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- std_to_flextable(all_responses, 'TypeItem', 'partID', 'FlexCat')
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>% #' ensures target sample did all 9 items
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
items <- names(part_flexbyitem)[-1] #item names from frame
N <- 100
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
boot_list <- bind_rows(holdout_nums, filter(boot_parts, n==0)) #participant IDs of holdout sample & resamples
boot_items <- all_responses %>%
filter(partID %in% boot_list$partID) #'outputs all responses for all items on boot_list
boot_response_count <- foreach(i = items, .combine='rbind') %do% sort_count(boot_items, i)
boot_ranks <- foreach(i = items, .combine='rbind') %do% ranks(boot_response_count, 100) #outputs MAUI rank table of bootstrap sample responses
View(boot_ranks)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
boot_ranks <- foreach(i = items, .combine='rbind') %do% ranks(boot_response_count, 100, i) #outputs MAUI rank table of bootstrap sample responses
View(boot_ranks)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
boot_ranks <- foreach(i = items, .combine='rbind') %do% ranks(boot_response_count, 100, i) #outputs MAUI rank table of bootstrap sample responses
View(boot_ranks)
boot_itemscores <- boot_response_count %>%
left_join(select(boot_ranks, -cumsum, -mass))
View(boot_itemscores)
boot_response_scores <- boot_response_count %>%
left_join(select(boot_ranks, -cumsum, -mass))
View(boot_response_scores)
View(boot_response_count)
View(boot_response_scores)
boot_scores <- boot_items %>%
left_join(boot_response_scores, by = 'Std') %>%
mutate(UI95 = ifelse(pct_giving <= .05, 1, 0)) %>%
group_by(partID) %>%
summarise(sum_MAUI = sum(MAUI),
avg_MAUI = mean(MAUI),
sum_UI95 = sum(UI95),
avg_UI95 = mean(UI95))
View(boot_scores)
boot_response_scores <- foreach(i = items, .combine='rbind') %do% left_join(filter(boot_response_scores, TypeItem == i), select(boot_ranks, -cumsum, -mass)) #' appends scores
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
boot_response_scores <- foreach(i = items, .combine='rbind') %do% append_scores(boot_response_scores, boot_ranks, i) #' appends scores
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
boot_response_scores <- foreach(i = items, .combine='rbind') %do% append_scores(boot_response_scores, boot_ranks, i) #' appends scores
View(boot_response_scores)
View(boot_list)
library(openxlsx)
library(foreach)
library(tidyverse)
library(readxl)
set.seed(1729)
#' Everything relative to project folder '#
source('code/bootstrapping subsample functions.R')
all_responses <- read_csv('data/Garrett Dissertation Data Answers Only.csv')
all_responses$Std <- str_replace_all(all_responses$Std, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
tolower() #' turns everything to lowercase
#' part_flexbyitem is a P x item frame of flex scores
#' crucially, NA means that the item was not completed by the P
part_flexbyitem <- std_to_flextable(all_responses, 'TypeItem', 'partID', 'FlexCat')
#' column of ID numbers in the target sample
holdout_nums <- part_flexbyitem %>%
na.omit() %>% #' ensures target sample did all 9 items
sample_n(100, replace = FALSE) %>%
select(partID)
#' P x item frame of those remaining
remains_flexbyitem <- part_flexbyitem %>%
filter(!partID %in% holdout_nums$partID)
items <- names(part_flexbyitem)[-1] #item names from frame
N <- 100
curve_formula <- formula(MAUI ~ ((d*(norm_rank)^g)/((d*(norm_rank)^g)+(1-norm_rank)^g)))
#' creates entire list of bootstrapped partIDs
#' note that not all of them have done all items
boot_parts <- foreach(i = seq(100, 800, by=100), .combine='rbind') %do% boot_nums(remains_flexbyitem, i)
boot_list <- bind_rows(holdout_nums, filter(boot_parts, n==0)) #participant IDs of holdout sample & resamples
#' creates response tables
boot_responses <- all_responses %>%
filter(partID %in% boot_list$partID) #'outputs all responses for all items on boot_list
boot_response_scores <- foreach(i = items, .combine='rbind') %do% sort_count(boot_responses, i) #' returns response count for standardized responses in a single df
boot_ranks <- foreach(i = items, .combine='rbind') %do% ranks(boot_response_scores, 100, i) #outputs MAUI rank table of bootstrap sample responses
#boot_calcs <- item_calcs(boot_ranks) #outputs MAUI rank table with 0 and 1 points
boot_response_scores <- foreach(i = items, .combine='rbind') %do%
append_scores(boot_response_scores, boot_ranks, i) #' appends scores
boot_participant_scores <- foreach(i = items, .combine='rbind') %do%
p_score(boot_responses, boot_response_scores, i) #' appends scores
View(boot_participant_scores)
>>>>>>> 0214ebae08a7638aa3c5770bdc548d18b802e0e2

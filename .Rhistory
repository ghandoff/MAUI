plot(split_tree)
View(split_mass_table)
split_tree <- ggplot(split_mass_table, aes(x = score, y = norm_rank, fill = measure, weight = mass_weight)) +
geom_split_violin(trim = TRUE) +
geom_boxplot(width = 0.25, notch = FALSE, notchwidth = .4, outlier.shape = NA, coef=0) +
labs(x=NULL,y="GM Attitude Score") +
theme_classic() +
theme(text = element_text(size = 20)) +
scale_x_discrete(labels=c("0" = "Control\nCondition", "1" = "GM\nCondition")) +
scale_fill_manual(values=c("#E69F00", "#999999"),
name="Survey\nPart",
breaks=c("1", "2"),
labels=c("Time 1", "Time 5"))
plot(split_tree)
View(raw)
View(p_scores)
library(openxlsx)
library(doParallel)
library(foreach)
library(tidyverse)
library(readxl)
#'This codelet operates on a single item
#' input file
#' first column must be named 'participant' and holds participant IDs
#' secon column must be named 'response' and holds the standardized responses
# raw <- read_csv('data/test data.csv')
# raw$response <- str_replace_all(raw$response, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
#   tolower() #' turns everything to lowercase
raw <- read_csv('data/Garrett GearToy Data_TwoColumn.csv')
names(raw) <- c('participant', 'response')
n <- length(unique(raw$participant)) #' calculates number of participants
UI_thresh <- .95 #' the 'old UI' threshhold, default at 95%
top_x <- 5 #' how many of the highest MAUI scores to use for the top X score
#' freq_table holds standardized responses and the frequency they occur in the item (i.e. the size of the fruit)
freq_table <- raw %>%
group_by(response) %>%
summarise(frequency = n())
#' mass_table has a bunch of intermediate calculations, and also the scores
#' 'frequency' is how often that response occurs in the item (fruit size)
#' 'count' is how many responses are of that frequency (i.e. how many fruits are on that level)
#' 'mass' is frequency*count (i.e. the total mass of fruit on that level)
#' 'cum_mass' is the mass of responses on that level and below
#' MAUI is calculated from the cum_mass of the level below + half of the current level mass
#' UI is calculated in the standard way from n and UI_thresh
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.))
#' appends MAUI and UI to freq_table
freq_table <- freq_table %>%
left_join(select(mass_table, -count, -mass, -cum_mass))
#' p_response_scores is the original data with MAUI and UI scores appended to each response
p_response_scores <- raw %>%
left_join(select(freq_table, -frequency))
#' calculates the top X score to append below
top_x_scores <- p_response_scores %>%
select(-UI) %>%
arrange(participant, desc(MAUI)) %>%
group_by(participant) %>%
slice(seq_len(top_x)) %>%
summarise(top_x_MAUI = sum(MAUI))
#' p_scores is a summary for each participant
#' current reports fluency, the sum of all MAUI scores and the sum of all UI scores
#' But very adaptable for new scores!
p_scores <- p_response_scores %>%
mutate(UI = if_else(UI >= UI_thresh, 1, 0)) %>%
group_by(participant) %>%
summarise(fluency = n(),
MAUI_sum = sum(MAUI),
UI_sum = sum(UI)) %>%
left_join(top_x_scores)
mass_table <- mass_table %>%
mutate(mass_weight = mass/max(cum_mass)) %>%
mutate(task = 'gears')
mass_graph <- ggplot(mass_table) +
geom_line(aes(norm_rank, MAUI), color = 'blue') +
geom_line(aes(norm_rank, UI), color = 'red')
response_tree <- ggplot(mass_table, aes(x = factor(task), y = norm_rank, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
MAUI_tree <- ggplot(mass_table, aes(x = factor(task), y = MAUI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
UI_tree <- ggplot(mass_table, aes(x = factor(task), y = UI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
View(mass_table)
install.packages('ggExtra')
bar <- ggplot(maSS_table, aes(x = task, y = mass_weight)) +
geom_bar(aes(fill = frequency))
bar <- ggplot(mass_table, aes(x = task, y = mass_weight)) +
geom_bar(aes(fill = frequency))
plot(bar)
bar <- ggplot(mass_table, aes(task, mass_weight)) +
geom_bar(aes(fill = frequency))
plot(bar)
bar <- ggplot(mass_table, aes(task, mass_weight)) +
geom_bar(aes(fill = frequency), stat = 'identity')
plot(bar)
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.),
freq_rank = dense_rank(frequency))
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.),
freq_rank_color = dense_rank(frequency)%%2)
bar <- ggplot(mass_table, aes(task, mass_weight)) +
geom_bar(aes(fill = freq_rank_color), stat = 'identity')
plot(bar)
library(openxlsx)
library(doParallel)
library(foreach)
library(tidyverse)
library(readxl)
#'This codelet operates on a single item
#' input file
#' first column must be named 'participant' and holds participant IDs
#' secon column must be named 'response' and holds the standardized responses
# raw <- read_csv('data/test data.csv')
# raw$response <- str_replace_all(raw$response, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
#   tolower() #' turns everything to lowercase
raw <- read_csv('data/Garrett GearToy Data_TwoColumn.csv')
names(raw) <- c('participant', 'response')
n <- length(unique(raw$participant)) #' calculates number of participants
UI_thresh <- .95 #' the 'old UI' threshhold, default at 95%
top_x <- 5 #' how many of the highest MAUI scores to use for the top X score
#' freq_table holds standardized responses and the frequency they occur in the item (i.e. the size of the fruit)
freq_table <- raw %>%
group_by(response) %>%
summarise(frequency = n())
#' mass_table has a bunch of intermediate calculations, and also the scores
#' 'frequency' is how often that response occurs in the item (fruit size)
#' 'count' is how many responses are of that frequency (i.e. how many fruits are on that level)
#' 'mass' is frequency*count (i.e. the total mass of fruit on that level)
#' 'cum_mass' is the mass of responses on that level and below
#' MAUI is calculated from the cum_mass of the level below + half of the current level mass
#' UI is calculated in the standard way from n and UI_thresh
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.))
#' appends MAUI and UI to freq_table
freq_table <- freq_table %>%
left_join(select(mass_table, -count, -mass, -cum_mass))
#' p_response_scores is the original data with MAUI and UI scores appended to each response
p_response_scores <- raw %>%
left_join(select(freq_table, -frequency))
#' calculates the top X score to append below
top_x_scores <- p_response_scores %>%
select(-UI) %>%
arrange(participant, desc(MAUI)) %>%
group_by(participant) %>%
slice(seq_len(top_x)) %>%
summarise(top_x_MAUI = sum(MAUI))
#' p_scores is a summary for each participant
#' current reports fluency, the sum of all MAUI scores and the sum of all UI scores
#' But very adaptable for new scores!
p_scores <- p_response_scores %>%
mutate(UI = if_else(UI >= UI_thresh, 1, 0)) %>%
group_by(participant) %>%
summarise(fluency = n(),
MAUI_sum = sum(MAUI),
UI_sum = sum(UI)) %>%
left_join(top_x_scores)
mass_table <- mass_table %>%
mutate(mass_weight = mass/max(cum_mass)) %>%
mutate(task = 'gears',
freq_rank_color = dense_rank(frequency)%%2)
mass_graph <- ggplot(mass_table) +
geom_line(aes(norm_rank, MAUI), color = 'blue') +
geom_line(aes(norm_rank, UI), color = 'red')
response_tree <- ggplot(mass_table, aes(x = factor(task), y = norm_rank, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
MAUI_tree <- ggplot(mass_table, aes(x = factor(task), y = MAUI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
UI_tree <- ggplot(mass_table, aes(x = factor(task), y = UI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
#####
# code for 'mega-viz'
bar <- ggplot(mass_table, aes(task, mass_weight)) +
geom_bar(aes(fill = freq_rank_color), stat = 'identity')
plot(bar)
#####
# code for 'mega-viz'
library(ggExtra)
bar_dens <- bar +
ggMarginal(type = 'density')
bar_dens <- ggMarginal(bar, type = 'density')
View(freq_table)
bar <- ggplot(mass_table) +
geom_bar(aes(task, mass_weight, fill = freq_rank_color), stat = 'identity')
plot(bar)
bar <- ggplot(mass_table) +
geom_bar(aes(task, mass_weight, fill = freq_rank_color), stat = 'identity', width = 5)
plot(bar)
bar <- ggplot(mass_table) +
geom_bar(aes(task, mass_weight, fill = freq_rank_color), stat = 'identity', width = 1)
plot(bar)
bar <- ggplot(mass_table) +
geom_bar(aes(task, mass_weight, fill = freq_rank_color), stat = 'identity', width = .2)
plot(bar)
library(openxlsx)
library(doParallel)
library(foreach)
library(tidyverse)
library(readxl)
#'This codelet operates on a single item
#' input file
#' first column must be named 'participant' and holds participant IDs
#' secon column must be named 'response' and holds the standardized responses
# raw <- read_csv('data/test data.csv')
# raw$response <- str_replace_all(raw$response, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
#   tolower() #' turns everything to lowercase
raw <- read_csv('data/Garrett GearToy Data_TwoColumn.csv')
names(raw) <- c('participant', 'response')
n <- length(unique(raw$participant)) #' calculates number of participants
UI_thresh <- .95 #' the 'old UI' threshhold, default at 95%
top_x <- 5 #' how many of the highest MAUI scores to use for the top X score
#' freq_table holds standardized responses and the frequency they occur in the item (i.e. the size of the fruit)
freq_table <- raw %>%
group_by(response) %>%
summarise(frequency = n())
View(freq_table)
View(raw)
library(openxlsx)
library(doParallel)
library(foreach)
library(tidyverse)
library(readxl)
#'This codelet operates on a single item
#' input file
#' first column must be named 'participant' and holds participant IDs
#' secon column must be named 'response' and holds the standardized responses
# raw <- read_csv('data/test data.csv')
# raw$response <- str_replace_all(raw$response, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
#   tolower() #' turns everything to lowercase
raw <- read_csv('data/Garrett GearToy Data_TwoColumn.csv')
names(raw) <- c('participant', 'response')
n <- length(unique(raw$participant)) #' calculates number of participants
UI_thresh <- .95 #' the 'old UI' threshhold, default at 95%
top_x <- 5 #' how many of the highest MAUI scores to use for the top X score
#' freq_table holds standardized responses and the frequency they occur in the item (i.e. the size of the fruit)
freq_table <- raw %>%
group_by(response) %>%
summarise(frequency = n())
#' mass_table has a bunch of intermediate calculations, and also the scores
#' 'frequency' is how often that response occurs in the item (fruit size)
#' 'count' is how many responses are of that frequency (i.e. how many fruits are on that level)
#' 'mass' is frequency*count (i.e. the total mass of fruit on that level)
#' 'cum_mass' is the mass of responses on that level and below
#' MAUI is calculated from the cum_mass of the level below + half of the current level mass
#' UI is calculated in the standard way from n and UI_thresh
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.))
#' appends MAUI and UI to freq_table
freq_table <- freq_table %>%
left_join(select(mass_table, -count, -mass, -cum_mass))
#' p_response_scores is the original data with MAUI and UI scores appended to each response
p_response_scores <- raw %>%
left_join(select(freq_table, -frequency))
#' calculates the top X score to append below
top_x_scores <- p_response_scores %>%
select(-UI) %>%
arrange(participant, desc(MAUI)) %>%
group_by(participant) %>%
slice(seq_len(top_x)) %>%
summarise(top_x_MAUI = sum(MAUI))
#' p_scores is a summary for each participant
#' current reports fluency, the sum of all MAUI scores and the sum of all UI scores
#' But very adaptable for new scores!
p_scores <- p_response_scores %>%
mutate(UI = if_else(UI >= UI_thresh, 1, 0)) %>%
group_by(participant) %>%
summarise(fluency = n(),
MAUI_sum = sum(MAUI),
UI_sum = sum(UI)) %>%
left_join(top_x_scores)
mass_table <- mass_table %>%
mutate(mass_weight = mass/max(cum_mass)) %>%
mutate(task = 'gears',
freq_rank_color = dense_rank(frequency)%%2)
mass_graph <- ggplot(mass_table) +
geom_line(aes(norm_rank, MAUI), color = 'blue') +
geom_line(aes(norm_rank, UI), color = 'red')
response_tree <- ggplot(mass_table, aes(x = factor(task), y = norm_rank, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
MAUI_tree <- ggplot(mass_table, aes(x = factor(task), y = MAUI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
UI_tree <- ggplot(mass_table, aes(x = factor(task), y = UI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
View(p_response_scores)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_jitter()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_dotplot()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_dotplot(binwidth = .01)
plot(mega)
library(openxlsx)
library(doParallel)
library(foreach)
library(tidyverse)
library(readxl)
#'This codelet operates on a single item
#' input file
#' first column must be named 'participant' and holds participant IDs
#' secon column must be named 'response' and holds the standardized responses
# raw <- read_csv('data/test data.csv')
# raw$response <- str_replace_all(raw$response, "[^[:alnum:]]", " ") %>% #gets rid of non alphanumerics
#   tolower() #' turns everything to lowercase
raw <- read_csv('data/Garrett GearToy Data_TwoColumn.csv')
names(raw) <- c('participant', 'response')
n <- length(unique(raw$participant)) #' calculates number of participants
UI_thresh <- .95 #' the 'old UI' threshhold, default at 95%
top_x <- 5 #' how many of the highest MAUI scores to use for the top X score
#' freq_table holds standardized responses and the frequency they occur in the item (i.e. the size of the fruit)
freq_table <- raw %>%
group_by(response) %>%
summarise(frequency = n())
#' mass_table has a bunch of intermediate calculations, and also the scores
#' 'frequency' is how often that response occurs in the item (fruit size)
#' 'count' is how many responses are of that frequency (i.e. how many fruits are on that level)
#' 'mass' is frequency*count (i.e. the total mass of fruit on that level)
#' 'cum_mass' is the mass of responses on that level and below
#' MAUI is calculated from the cum_mass of the level below + half of the current level mass
#' UI is calculated in the standard way from n and UI_thresh
mass_table <- freq_table %>%
group_by(frequency) %>%
summarise(count = n()) %>%
arrange(desc(frequency)) %>%
mutate(mass = frequency*count) %>%
mutate(cum_mass = cumsum(mass)) %>%
mutate(MAUI = (cum_mass - mass/2)/max(cum_mass),
UI = 1 - frequency/n,
norm_rank = (rank(cum_mass) - .5)/nrow(.))
#' appends MAUI and UI to freq_table
freq_table <- freq_table %>%
left_join(select(mass_table, -count, -mass, -cum_mass))
#' p_response_scores is the original data with MAUI and UI scores appended to each response
p_response_scores <- raw %>%
left_join(select(freq_table, -frequency)) %>%
ungroup()
#' calculates the top X score to append below
top_x_scores <- p_response_scores %>%
select(-UI) %>%
arrange(participant, desc(MAUI)) %>%
group_by(participant) %>%
slice(seq_len(top_x)) %>%
summarise(top_x_MAUI = sum(MAUI))
#' p_scores is a summary for each participant
#' current reports fluency, the sum of all MAUI scores and the sum of all UI scores
#' But very adaptable for new scores!
p_scores <- p_response_scores %>%
mutate(UI = if_else(UI >= UI_thresh, 1, 0)) %>%
group_by(participant) %>%
summarise(fluency = n(),
MAUI_sum = sum(MAUI),
UI_sum = sum(UI)) %>%
left_join(top_x_scores)
mass_table <- mass_table %>%
mutate(mass_weight = mass/max(cum_mass)) %>%
mutate(task = 'gears',
freq_rank_color = dense_rank(frequency)%%2)
mass_graph <- ggplot(mass_table) +
geom_line(aes(norm_rank, MAUI), color = 'blue') +
geom_line(aes(norm_rank, UI), color = 'red')
response_tree <- ggplot(mass_table, aes(x = factor(task), y = norm_rank, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
MAUI_tree <- ggplot(mass_table, aes(x = factor(task), y = MAUI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
UI_tree <- ggplot(mass_table, aes(x = factor(task), y = UI, weight = mass_weight)) +
geom_violin() +
geom_boxplot(width = 0.1)
#####
# code for 'mega-viz'
library(ggExtra)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_dotplot(binwidth = .01)
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_dotplot(binwidth = .01) +
geom_density()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_dotplot(binwidth = .01) +
geom_freqpoly()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_area(binwidth = .01)
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_area(stat = 'bin')
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .01)
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .01, stat = 'density')
mega <- ggplot(p_response_scores, aes(MAUI, stat(density))) +
geom_histogram(binwidth = .01)
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .01, aes(y=..count../sum(..count..)))
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..)))
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density(aes(y=..count../sum(..count..)))
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..)))
marg_mega <- ggMarginal(mega, type = 'density')
plot(marg_mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density()
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density(stat(count))
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density(aes(stat(count)))
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI)) +
geom_histogram(binwidth = .005, aes(y=..count../sum(..count..))) +
geom_density(aes(stat(scaled)))
plot(mega)
mega <- ggplot(p_response_scores, aes(MAUI, y=..count../sum(..count..))) +
geom_histogram(binwidth = .005) +
geom_density()
plot(mega)
library(tidyverse)
library(lubridate)
library(ggplot2)
sorted <- read_csv('C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/Final Presentation Peer Feedback.csv')
library(tidyverse)
library(readxl)
sorted <- read_csv('C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/Final Presentation Peer Feedback.csv') %>%
group_by(group) %>%
mutate(obs = row_number()) %>%
gather(type, comment, -group, -obs) %>%
mutate(obs = sprintf("%02d", obs)) %>%
unite("unit", c("type","obs"), sep = "_") %>%
spread(unit, comment)
write_csv(sorted, 'C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/sorted feedback.csv')
library(tidyverse)
library(readxl)
sorted <- read_csv('C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/Final Presentation Peer Feedback.csv') %>%
group_by(group) %>%
mutate(obs = row_number()) %>%
gather(type, comment, -group, -obs) %>%
mutate(obs = sprintf("%02d", obs)) %>%
unite("unit", c("type","obs"), sep = "_") %>%
spread(unit, comment)
write_csv(sorted, 'C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/sorted feedback.csv')
library(tidyverse)
library(readxl)
sorted <- read_csv('C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/Final Presentation Peer Feedback.csv') %>%
group_by(group) %>%
mutate(obs = row_number()) %>%
gather(type, comment, -group, -obs) %>%
mutate(obs = sprintf("%02d", obs)) %>%
unite("unit", c("type","obs"), sep = "_") %>%
spread(unit, comment)
write_csv(sorted, 'C:/Users/Zach/Documents/SpiderOak Hive/Teaching/Decision Making/Undergrad Spring 2019/sorted feedback.csv')
